import uuid
from typing             import Optional, TYPE_CHECKING, Generator, Any
from pyoxigraph         import NamedNode, Triple, Literal
from cellini.odm.utils  import literal_rdf_to_python, literal_python_to_rdf, UnsupportedType, RDF
from cellini.odm.base   import AbstractNamedNode, registry


def python_value_to_triples(subject:NamedNode, predicate:NamedNode, python_value:Any, recursive=True)->Generator[Triple, None, None]:
    """
    Helpfull function to convert any python value to rdf triples 
    """
    
    # If the field value is a list then we wrap it as rdf:Bag
    if type(python_value) is list:
        python_value = Bag(python_value)

    # If python_value type is included in our registry then it points to 
    # an AbstractNamedNode model so we use it's autogenerated uri.
    if type(python_value) in registry:

        yield Triple(subject, predicate, python_value.__rdf_uri__)

        # If recursive is set to true then we return all models' sub-triples (if any)
        if recursive:
            for t in python_value.to_triples():
                yield t

    # Otherwise the field is expected to point to a literal type 
    # so we convert it and return the corresponding triple 
    else:
        value = literal_python_to_rdf(python_value)
        if value:
            yield Triple(subject, predicate, value)




class Bag(list, AbstractNamedNode):

    """
    Bag is a python List type that implements rdf:Bag specification.

    As long as rdf schema doesnt support Ordered Lists natively, 
    rdf:Bag class is used to fill this gap.

    [see](https://www.w3.org/2007/02/turtle/primer/#figure14)
    """

    def __init__(self, *arg, node:Optional[NamedNode]=None):
        if isinstance(node, NamedNode):
            self._identifier = node.value.split(f"{self.__rdf_title__()}:")[-1]
        elif node == None:
            self._identifier = uuid.uuid4()
        else:
            raise ValueError(f"{self} `node` attribute received an unexpected type")
        super().__init__(*arg)

    @property
    def identifier(self):
        return self._identifier

    @classmethod
    def __rdf_title__(cls)->str:
        return f"{registry.uri_prefix}{cls.__name__}"

    def to_triples(self, recursive=True):
        yield Triple(self.__rdf_uri__, RDF.type, RDF.Bag)
        i = 1
        for item in self:
            for triple in python_value_to_triples(
                            self.__rdf_uri__, 
                            NamedNode(f"http://www.w3.org/1999/02/22-rdf-syntax-ns#_{i}"),
                            item,
                            recursive=recursive):
                yield triple
            i += 1

    @classmethod
    def resolve_named_node(cls, node:NamedNode)->AbstractNamedNode:

        data = cls(node=node)

        for s, p, o in registry.query(f"DESCRIBE {node}"):

            if p == RDF.type:
                if o != RDF.Bag:
                    raise ValueError(f"Expected RDF.Bag type but got {o}")
                continue
            
            idx = int(p.value.split('_')[1])
            if isinstance(o, Literal):
                value = literal_rdf_to_python(o)
            elif isinstance(o, NamedNode):
                value = registry.resolve_named_node(o)
            else:
                raise UnsupportedType(f"Unexpected triple type recieved {type(o)} (value={o})")            

            data.insert(idx, value)

        return data

registry.add(Bag)